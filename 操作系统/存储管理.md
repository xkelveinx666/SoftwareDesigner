# 存储管理
### 程序操作步骤
- 编译:源代码 -> 目标模块
- 链接:目标模块 -> 装入模块, 装入模块 = 目标代码 + 所需库函数 
- 装入(地址重定位):装入模块装入内存实际物理地址空间
### 重定位
- 逻辑地址 = 硬盘地址 = 相对地址
- 物理地址 = 内存地址 = 绝对地址
- 地址重定位(地址映射):完成相对地址到内存地址的转化
- 静态重定位:装入内存重定位
- 动态重定位:程序执行时重定位

### 固定分区和可变分区
- 固定分区:一旦划分好，运行期间不能重新划分
- 可变分区:把可用内存空间"切除"一个连续的区域分配给进程，以适应进程大小的需要,根据装入进程大小动态划分
### 可变分区算法
1. 首次适应算法
> - 空闲分区以地址递增的次序排序,每次都从链首或链尾找到第一个大小可以满足的分区
> - 容易形成碎片
> - 不重新排序
2. 下次适应算法
> - 空闲分区以地址递增的次序排序,每次从上次找到空闲分区的下一个开始查找
> - 减少了大空闲分区，大进程无法进入
> - 不重新排序
3. 最佳适应算法
> - 将空闲分区以容量大小递增排序，从链首找第一个满足的空闲区
> - 产生大量很小的空闲区
> - 重新以容量递增排序
4. 最差适应算法
> - 将空闲分区以容量大小递减排序，从链首找第一个满足的空闲分区，若第一个不满足则肯定不存在满足进程的分区
> - 有较大进程进入时，往往不能满足要求
> - 重新以容量递减排序
- 最佳不一定最佳，最差不一定最差。
- 一般情况下，最简单，最快最好的算是是首次适应算法
### 页式存储
#### 基本原理:将内存划分为一系列的大小相等的块，将逻辑地址空间划分成与内存大小相等的页，编号并进行重定位建立页表
- 块 ＝ 物理空间 = 内存空间
- 页 ＝ 逻辑空间 = 硬盘空间 = 外存空间
##### 系统为每个进程建立一张页表，页表实现了从页号到物理块号的地址映射
> - 逻辑地址 = 页号 ＋(连接) 页内位移(页面大小)
> - 页号 = 逻辑地址 / 页面大小
> - 页内偏移量 ＝ 逻辑地址 % 页面大小 
> - 逻辑地址的页面大小 = 物理地址的页面大小

|条件|结果|
|-|-|
|逻辑地址的页号没有在题目中给出|缺页中断|
|逻辑地址的页号大于寄存器的页表长度|越界中断|
|逻辑地址的页号大于存储器大小|越界中断|
### 段式存储
#### 基本原理: 将进程对应的程序和数据按本身特性分成若干段，每个段有段号,每个段长度不定
##### 系统为每个进程建立一个段表，由段号，段长，段始址组成
- 段长度 = 段内地址
## 第六章
### 局部性原理
- 程序访问内存单元具有局部性
- 时间局部性:程序中的某条指令一旦执行，不久后会再次执行
- 空间布局性:程序一旦访问某存储单元，不久后会访问其附近的存储单元
#### 虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统
- 离散性:作业不装入连续的存储空间
- 多次性:一个作业被分割，多次掉入内存
- 对换性:作业在运行过程中换进、换出内存
- 虚拟性:从逻辑上扩充了内存的容量
#### 虚拟存储器的最大容量由计算机结构(CPU寻址能力、地址线，位数)确定
### 请求页式存储管理页面置换算法
1. 最佳置换算法OPT
> - 选择将来最长时间未访问的页面，进行置换
> - 需要已知页面访问序列
> - 缺页率最低
2. 先进先出算法FIFO
> - 置换最早进入内存的页、驻留时间最久的页，类似队列
> - 加载时间最快
> - 缺页率高
3. 最近最久未使用置换算法LRU
> - 置换最近一段时间内最久未使用的页面
> - 访问时间最快
4. 时钟置换算法CLOCK
> - 访问位与修改位均为0
- 发生页面置换，则有缺页中断
- 缺页率 = 缺页次数 / 访问次数